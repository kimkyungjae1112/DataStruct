# 트리 자료구조 정리

## 1. 이진 트리 (Binary Tree)

### 개념
- 각 노드가 최대 2개의 자식 노드를 가지는 트리 구조
- 순회 방식: 전위 순회, 중위 순회, 후위 순회, 레벨 순회 등

### 시간 복잡도
- 평균: O(log N)
- 최악: O(N) (편향 트리인 경우)

### 특징
- 노드 당 최대 2개의 자식
- 정렬이나 균형에 대한 보장은 없음

<br>

---

<br>

## 2. 이진 탐색 트리 (Binary Search Tree, BST)

### 개념
- 왼쪽 자식 노드는 루트보다 작고, 오른쪽 자식 노드는 루트보다 큰 값을 가지는 트리

### 시간 복잡도
- 평균: O(log N)
- 최악: O(N) (편향될 경우)

### 특징
- 정렬된 구조를 가짐
- 삽입/탐색/삭제 가능
- 입력 순서에 따라 성능이 달라짐
- 중복을 허용하지 않는 것이 일반적

<br>

---

<br>

## 3. 균형 이진 탐색 트리 (Adelson-Velsky and Landis, AVL)

#### 개념
- 노드마다 높이 차(균형 인자)를 유지하며 트리의 균형을 맞춤

#### 시간 복잡도
- 항상 O(log N)

#### 특징
- 탐색 속도가 빠름
- 삽입 및 삭제 시 회전 연산이 자주 발생
- 균형 유지가 엄격함

### 레드-블랙 트리

#### 개념
- 노드에 Red 또는 Black 색을 부여하여 트리의 균형을 유지하는 방식

#### 시간 복잡도
- 항상 O(log N)

#### 특징
- AVL보다 균형 조건이 느슨함
- 삽입/삭제 시 연산이 효율적
- C++ STL의 map, set 등이 내부적으로 사용

<br>

---

<br>

## 4. 힙 (Heap)

### 개념
- 최대값이나 최소값을 빠르게 꺼낼 수 있도록 구성된 완전 이진 트리

### 시간 복잡도
- 삽입: O(log N)
- 삭제(루트): O(log N)
- 루트 조회: O(1)

### 특징
- 최대 힙: 부모 노드 ≥ 자식 노드
- 최소 힙: 부모 노드 ≤ 자식 노드
- 완전 이진 트리이므로 배열로 구현하기 좋음
- 우선순위 큐 구현에 사용됨

<br>

---

<br>

## 5. 트라이 (Trie)

### 개념
- 문자열을 문자 단위로 분해하여 노드에 저장하는 트리 구조

### 시간 복잡도
- 삽입/탐색: O(L) (L은 문자열 길이)

### 특징
- 문자열의 공통 접두사를 공유
- 자동완성, 사전 구현에 활용
- 메모리 사용량이 크지만 검색 속도가 빠름
- 노드마다 자식들을 배열이나 해시맵으로 관리

<br>

---

<br>

## 비교 요약

| 자료구조        | 삽입       | 삭제       | 탐색       | 특징                               |
|----------------|------------|------------|------------|------------------------------------|
| 이진 트리      | O(N)       | O(N)       | O(N)       | 일반 트리, 정렬/균형 조건 없음     |
| BST            | O(log N)*  | O(log N)*  | O(log N)*  | 정렬된 구조, 최악 O(N) 가능        |
| AVL 트리       | O(log N)   | O(log N)   | O(log N)   | 탐색 빠름, 회전 많음              |
| 레드-블랙 트리 | O(log N)   | O(log N)   | O(log N)   | STL 사용, 삽입/삭제 효율적         |
| 힙             | O(log N)   | O(log N)   | O(1)       | 우선순위 큐, 최대/최소값 빠르게 추출 |
| 트라이         | O(L)       | O(L)       | O(L)       | 문자열 검색 특화, 메모리 소비 큼  |
